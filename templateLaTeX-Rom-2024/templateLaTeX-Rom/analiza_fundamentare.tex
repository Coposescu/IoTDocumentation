\chapter{Analiză și fundamentare teoretică}
\label{ch:analysis}
\pagestyle{fancy}

\section{Protocoale de comunicatie}\label{sec:protocols}
\subsection{protocolul TCP/IP}\label{subsec:tcpip}
\subsection{HTTP}\label{sec:http}
\subsection{MQTT}\label{sec:mqtt}
Standardul MQTT defineste un set de reguli, un limbaj, pe care doua sau mai multe entitati trebuie sa il respecte pentru a putea schimba mesaje intre 
ele. Entitatile acestuia sunt clientii si un server, numit Broker. Este un protocol pentru transmiterea mesajelor prin internet care necesita resurse reduse si 
utilizeaza un model de comunicatie de tip publica/aboneaza. In mod uzual opereaza impreuna cu stiva de comunicatie TCP/IP, dar poate fi integrat si cu alte 
standarde, cum ar fi ZigBee sau LoRa. Acest protocol este foarte utilizat in domeniul Internetul Lucrurilor fiind potrivit pentru 
senzorii cu capacitati de procesare reduse si oferind un grad inalt de scalabilitate prin structura de functionare a acestuia. In urmatoarele paragrafe 
din acest capitol vom analiza caracteristicile cheie ale acestui protocol.

Broker-ul este un server, o unitate centrala, specializat pe receptia mesajelor de la clienti si retransmisia acestora catre clientii interesati de 
tipul de mesaj respectiv. Acesta poate fi vizualizat ca o unitate de decuplare, deoarece clientii nu comunica direct intre ei, ci prin acest manager de 
mesaje. Comunicarea este de tip asincrona, calea unei tranzactii porneste de la client si se opreste la Broker, deci o tranzactie nu implica doi clienti 
in acelasi timp. 

Modelul de comunicatie publica/aboneaza imparte clientii in doua categorii, clienti care publica, transmit, mesaje catre Broker si clienti care se aboneaza
la Broker pentru a receptiona mesajele publicate. Clientii pot avea ambele roluri, si de publicatori si de abonati, pastrand rolurile disjuncte. Astfel ca 
un client care are ambele roluri va publica periodic un set de date si in acelasi timp va fi abonat la Broker pentru receptia de mesaje de la unul sau mai 
multi clienti. In mod uzual aceste roluri pot fi impartite in doua categorii, rol principal si rol secundar. In cazul uni senzor, rolul principal este 
de a publica date despre mediul inconjurator, iar rolul secundar este de abonare pentru a receptiona modificari ale configuratiilor acestuia, de exemplu, 
perioada la care se face publicarea. In cazul unui client smartphone sau pagina web, rolul principal este de abonat pentru a receptiona metricile de la senzori, 
iar rolul secundar este de publicator pentru transmisia de configuratii catre senzor.

Figura \ref{fig:MQTTBrokerArchitecture} prezinta arhitectura publica/aboneaza a protocolului de comunicatie MQTT. Fiecare modul prezentat in figura este 
descris in paragrafele de mai sus.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{figs/MQTTBrokerArchitecture.png}
    \caption{Arhitectura publica/aboneaza a protocolului MQTT}
    \label{fig:MQTTBrokerArchitecture}
\end{figure}

Subeictul mesajelor, denumit topic in standard [1], reprezinta o serie de cuvinte structurate pe nivele care descriu intr-un mod succint datele mesajului. 
Aceste cuvinte sunt separate prin caracterul special "/", denumit si separator de nivel [1], si au rolul de a filtra mesajele trimise catre clienti. 
De exemplu, Un senzor transmite un mesaj care contine date de temperatura catre Broker sub subiectul "IDsenzor/citiri/temperatura". 
Broker-ul va redirectiona acest mesaj doar catre clientii care sunt abonati pentru receptia de mesaje care au subiectul "IDsenzor/citiri/temperatura".

Structura unui mesaj MQTT este de tip binar, fiecare bit sau grupare de biti indentifica un tip de mesaj sau diferite proprietati, in comparatie cu alte 
protocoale de comunicatie care utilizeaza un format bazat pe text, unde tipurile de mesaje sau proprietatile sunt identificate prin text, de exemplu,
protocolul de comunicatie HTTP. Principalul avantaj al formatului de tip binar este dimensiunea scazuta a pachetului. Tabelul \ref{tab:StructuraMesajMQTT} 
contine o prezentare generala a acestui pachet unde:
\begin{itemize}
	\item Control Field - reprezinta octetul de control al pachetului si este impartit in doua zone:
    \begin{itemize}
        \item Tipul pachetului in primii 4 biti
        \item Semnale pentru activarea sau dezactivarea unor proprietati
    \end{itemize}
	\item Remaining Length - poate avea o lungime cuprinsa intre 1 si 4 octeti si reprezinta lungimea ramasa in pachet, adica lungimea campurilor Variable Header 
    si Payload
	\item Variable Header - are o lungime variabila care este cuprinsa in campul precedent. Acest camp difera in functie de tipul mesajului, de exemplu, in 
	cazul mesajului de publicare a datelor acest camp contine subiectul.
	\item Payload - are o lungime variabila care este cuprinsa in campul Remaining Length si reprezinta partea utila a mesajului, de exemplu, datele citite de 
	la senzor.
\end{itemize}

\begin{table}[ht]
    \caption{Structura mesaj MQTT}
    \centering                          % tabel centrat
    \begin{tabular}{|c|c|c|c|}          % 4 coloane centrate
        \hline
        1 B & 1-4 B & x B & x B \\ [0.5ex]   % inserare tabel
        %heading
        \hline                              % linie orizontal simpla
        Control Field & Remaining Length & Variable Header & Payload \\               % corpul tabelului
        \hline
    \end{tabular}
    % titlul tabelului
    \label{tab:StructuraMesajMQTT}                % eticheta folosita pentru referirea tabelului in text; referirea in text se va face cu \ref{table:nonlin}
\end{table}

Tranzactia reprezinta un schimb de mesaje intre un client si Broker si are o structura de tip cerere si confirmare. Cererea este un mesaj care contine informatii 
utile, de exemplu, datele unui senzor sau datele necesare conectarii la Broker, iar confirmarea este un mesaj prin care Borker-ul instiinteaza clientul ca cererea 
lui a fost inregistrata. Acestea din urma sunt transmise si in caz de eroare si in caz de success, iar acest lucru este semnalat in campul "Variable Header" 
prezentat in tabelul \ref{tab:StructuraMesajMQTT}. Protocolul MQTT contine mai multe tipuri de mesaje impartite pe cele doua categorii prezentate mai sus dintre 
care cele mai importante sunt prezentate in cele ce urmeaza:
\begin{itemize}
    \item CONNECT - acest pachet este trimis de catre client pentru a realiza o conexiune cu Broker-ul.
    \item CONNACK - acest pachet este trimis de catre Broker si reprezinta raspunsul pentru mesajul CONNECT si are rolul de a confirma realizarea conexiunii.
    \item PUBLISH - acest pachet este trimis de catre client si contine subiectul si datele utile.
    \item PUBACK - acest pachet este trimis de catre Broker ca raspuns la mesajul PUBLISH.
    \item SUBSCRIBE - acest pachet este trimis de catre client si reprezinta cererea de abonare la un anumit subiect. Subiectul este continut in pachet.
    \item SUBACK - acest pachet este trimis de catre Broker si reprezinta confirmarea subscriptiei clientului.
\end{itemize}

Conexiunea dintre client si Broker se realizeaza la cererea clientului print trimiterea unui mesaj specific. Acest tip de mesaj contine un camp special 
denumit "keep alive" prin care clientul informeaza Broker-ul de durata de viata a conexiunii dintre acestia. Clientul poate alege inchiderea conexiunii 
cu Broker-ul dupa fiecare mesaj de publicare a datelor cu scopul de a intra intr-un mod de consum de putere redus pana la urmatoarea perioada de 
publicare. Salvarea energiei aduce cu sine cresterea numarului de mesaje interschimbate intre client si Broker, dar aduce avantaje in durata de viata 
a bateriei. 

\subsection{Wi-Fi}\label{sec:wifi}
\subsection{SPI}\label{sec:spi}
\subsection{I2C}\label{sec:i2c}
\section{Modele abstracte}\label{sec:modele}
\subsection{RESTful API}\label{sec:restapi}
RESTful semnifica Representational State Transfer Application Programmin Interface si reprezinta un set de reguli care trebuie respectate in construirea 
unei arhitecturi web pentru a beneficia de cerinte non-functionale precum, un grad mare de scalabilitate, reliabilitate si adaptabilitate. Acest set de 
reguli are ca scop decuplarea in grad cat mai mare a clientului de sarcinile serverului. In paragrafele urmatoare se vor detalia caracteristicile cheie 
ale stilului arhitectural RESTful.

API semnifica Application Programming Interface si reprezinta o interfata intre client si server in care atributiile serverului sunt de a oferi 
clientului servicii prin care acesta poate obtine si stoca date intr-o baza de date. Alte functionalitati care se doresc a fi implementate trebuie 
sa fie in sarcina clientului, deci clientul trebuie sa se asigure ca cererea pe care o trimite catre server contine toate informatiile necesare. 
De exemplu, serverul nu retine informatii de securitate, ci aceste informatii trebuie continute in pachetul trimis de catre cient.

Figura \ref{fig:RESTfulStructure} prezinta structura unei arhitecturi RESTful. Fiecare modul va fi descris in paragrafele urmatoare.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{figs/RESTfulStructure.png}
    \caption{Structura arhitecturii RESTful}
    \label{fig:RESTfulStructure}
\end{figure}

Principalul modul din arhitectura RESTful este modulul Resources, care semnifica resursa. O resursa reprezinta un set de date pe care un client il poate 
cere serverului prin transmiterea unui URL. Detalii despre URL se gasesc in capitolul \ref{sec:http}. Acesta reprezinta un identificator unic pentru 
fiecare resursa. Nu este necesar ca o resursa sa implementeze toate metodele HTTP, daca o metoda nu este implementata va fi returnat raspunsul de eroare 
405 semificand ca metoda nu este permisa. Exemplu de tranzactie intre client si server cu accentul pe resurse:
\begin{enumerate}
	\item clientul trimite un URL catre server
	\item serverul identifica resursa asociata URL-ului
	\item serverul interogheaza baza de date pentru resursa specificata
	\item serverul trimite un raspun care contine resursa ceruta si un status al tranzactiei
\end{enumerate}

Modulul Routes se ocupa de partea de rutare a cererilor primite de la client. Acest modul identifica pe baza adresei URL resursa de care clientul are nevoie, 
iar apoi informeaza modulul Resource Manager in legatura cu aceasta resursa.

Modulul Model se ocupa de operatiile cu baza de date, operatiile CRUD. Aceste operatii sunt creare, citire, modificare si stergere a unei intrari din 
baza de date. Rezultatul operatiei cu baza de date este returnat modulului Resource Manager.

Modulul Resource Manager este modulul central al acestei structuri si se ocupa cu extragerea resursei primita de la modulul Routes si a metodelor specifice 
acesteia, de exemplu, metodele HTTP GET si POST. Bazat pe aceste metode, modulul Resource Manager interogheaza baza de date. Raspunsul primit de la baza de date 
este validat si trimis catre modulul View.

Modulul View are sarcina de a formata datele primite de la modulul Resource Maganer in structura la care clientul se asteapta, apoi trimitand raspunsul catre 
client. 

Arhitectura RESTful API este asemanatoare cu modelul de design MVC, care semnifica Model View Controller si reprezinta o structurare a software-ului intern 
in trei module separate, Model si View care sunt identice cu modelele Model si View din RESTful API si Controller care inlocuieste modulul resource Manager 
din RESTful API.

Setul de reguli ce trebuie respectate pentru implementarea unei arhitecturi RESTful cuprind:
\begin{enumerate}
	\item Arhitectura aplicatiei trebuie sa fie de tipul client-server. Clientul trebuie separat de srever si de operatiile cu baza de date. Fiecare 
    participant al unei tranzactii trebuie sa fie independent de ceilalti.
	\item Lipsa starii inseamna ca o cerere trimisa de client trebuie sa contina toate informatiile necesare pentu ca aceasta sa fie onorata. Serverul 
	nu are voie sa retina informatii legate de client.
    \item Interfata uniforma specifica ca structura adreselor URL trebuie sa fie definita foarte clar, deoarece acestea reprezinta identificatorii unici 
    ai resurselor si implicit indentificarea corecta a resursei dorite.
    \item Clientul sau o alta componenta din retea poate sa retina raspunsurile de la server care sunt semnalate ca fiind memorabile cu scopul 
    optimizarii. 
    \item System pe nivele inseamna ca fiecare nivel este constient doar de nivelele din imediata apropiere a lui si ca intre server si client mai pot fi 
    adaugate nivele precum un server proxy.
\end{enumerate}

O metoda de versionare a software-ului unui server este prin adaugarea in adresa URL a unui numar care sa identifice unic o versiune, de exemplu, v1.1. 
Astfel se elimina problemele in care dupa o imbunatatire a software-ului, clientii care nu au aplicat modificarea nu mai pot accesa anumite resurse. 
Dezavantajul acestei metode este complexitatea software-ului din server care creste cu fiecare imbunatatire. Cu toate acestea, este considerata metoda 
cea mai avantajoasa.

\subsection{Flask framework}\label{sec:flask}
Framework-ul Flask este o biblioteca software de module reutilizabile care are scopul de a automatiza si standardiza modul in care sunt scrise aplicatiile 
web. Acesta este scris in limbajul de programare Python si este denumit micro-framework, deoarece are o complexitate redusa. Acesta contine doar module 
cu functionalitati de baza necesare in creearea unei aplicatii web, alte functionalitati care se doresc in aplicatie, cum ar fi utilizarea unei baze de 
date, fiind la latitudinea utilizatorului. In paragrafele urmatoare se vor detalia caracteristicile cheie ale ale framework-ului Flask.

Figura \ref{fig:FlaskProjectStructure} prezinta structura unui proiect Python utilizand framework-ul Flask.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{figs/FlaskProjectStructure.png}
    \caption{Structura unui proiect Python utilizand Flask}
    \label{fig:FlaskProjectStructure}
\end{figure}

Structura de proiect prezentata in figura \ref{fig:FlaskProjectStructure} este detaliata in cele ce urmeaza:
\begin{enumerate}
	\item Fisierul flasky.py contine apelul prin care obiectul Flask este pornit, metoda run(). Aceasta metoda primeste ca parametrii adresa si 
    portul prin care serverul poate fi accesat. Este punctul principal, sau punctul de intrare in aplicatie si reprezinta o bucla infinita 
    in care sunt deservite cererile de la client.
	\item Fisierul requirements.txt contine numele bibliotecilor utilizate in proiect si versiunile acestora. Este un fisier foarte util atunci 
	cand o persoana preia proiectul pe o masina diferita si are nevoie sa creeze un mediu de lucru. Continutul acestui fisier poate fi usor generat 
    de comanda "pip freeze".
    \item Directorul venv/ contine toate bibliotecile instalate, cele continute in fisierul requirements.txt, si o referinta catre versiunea de python 
    utilizata. Astfel se creeaza un mediu de lucru separat fata de ceea ce este instalat global pe computer sau de alte proiecte. Acest director 
    trebuie creeat in faza de initiere a proiectului si atunci cand este preluat pe o alta masina de lucru.
    \item Directorul app contine fisierele aplicatiei, toate fisierele necesare ca aplicatia sa ruleze. Directoarele pentru testare si migrari sunt 
    separate.
    \item Fisierul view.py contine partea de rutare a cerintelor primite de la client catre resurse prin decoratori sau prin metode statice si 
    partea de formatare a raspunsului in structura asteptata de client. Acest fisier poate fi impartit in doua modula separate, routes.py si 
    view.py, fiecare avand o sarcina bine definita.
    \item Fisierul \_\_init\_\_.py din directorul app contine instantierea clasei Flask. Acest obiect se ocupa de toate cererile care vin de la client. 
    Pe langa instantiere mai poate contine metode de initializare a diferite module sau biblioteci pe care aplicatia le utilizeaza, cum ar fi conexiunea 
    la baza de date sau un sistem de versionare. Orice director care contine acest fisier este considerat un packet reutilizabil care poate fi inclus si 
    utilizat intr-o alta aplicatie. Atunci can directorul app este inclus in aplicatie, continutul fisierului \_\_init\_\_.py este prima portine de 
    cod care se ruleaza din acel pachet. 
\end{enumerate}

Decoratorii in python reprezinta o metoda prin care se seteaza o portiune de cod care sa fie executata atunci cand anumite evenimente au loc. De exemplu, 
la primirea unei cereri de la client decoratorul spune care portiune de cod, metoda, trebuie executata. In general aceasta metoda poarta denumirea de 
Handler. Decoratorii de tip route fac legatura intre adresa URL primita de la client si metodele resursei indentificata unic de adresa URL. Modul in  
care aceasta legatura este realizata de Flask, este prin creearea unei mapari a adreselor URL pe resurse.

Argumentele dinamice in adresa URL sunt adrese URL de baza care identifica o resursa, dar care au in plus un argument ce poate lua orice valoare. Acest 
argument este preluat de catre resursa si pe baza lui raspunsul care s-ar fi trimis in mod normal este personalizat generand un raspuns diferit.

Flask ofera un serviciu numit Request Hooks care ofera posibilitatea de a executa portiuni de cod inainte ca fiecare cerere de la client sa fie procesata, 
inainte doar de prima cerere de la client sau dupa ce cererea a fost procesata. Acest serviciu este util pentru cazurile in care se doreste realizarea 
conexiunii la baza de date sau autentificarea clientului de fiecare data cand o cerere este receptionata. Avantajul utilizarii acestui serviciu este 
cantitatea redusa de cod duplicat. Il loc sa se realizeze autentificarea in fiecare rutina specifica unei resurse, se realizeaza in mod generic inainte ca 
resursa sa fie accesata.

Cazurile de eroare, in Flask, pot fi personalizate. La primirea unei cereri de la client, daca aceasta este eronata, se poate transmite ca raspuns, pe langa 
codul de eroare, o pagina HTML sau un text care sa explice de ce a fost respinsa cererea.

Unele framework-uri din Python contin setul de instructiuni pentru integrara cu Flask, dar, dupa cum am prezentat si mai sus, Flask a fost creat pentru a fi 
integrat cu module externe, deci instructiunile necesare pentru integrarea cu acesta pot fi scrise de utilizator. Un exemplu de framework pentru baze de date 
care este integrat cu Flask este Flask-SQLAlchemy.

Micro-framework-ul Flask are un grad de flexibilitate foarte inalt comparat cu un full-framework. Flask a fost creat pentru a automatiza doar functionalitatile 
de baza necesare unei apicatii web, ceea ce inseamna ca nu are integrate componente pentru autentificare sau operatii pe baze de date, dar este 
compatibil cu componente externe. Acest lucru ofera posibilitatea de a utiliza framework-ul impreuna cu orice fel de baza de date sau orice tip de 
autentificare. Pe cealalta parte, un framework full, ca Django, ofera o gama de componente care pot fi utilizate pentru functionalitati precum 
operatiile pe baze de date si autentificare, deci utilizatorul este restrans in ceea ce priveste functionalitatile proiectului lui.

\subsection{Retrofit framework}\label{sec:retrofit}
Retrofit este o biblioteca scrisa in limbajul de programare Java care are scopul de a simplifica tranzactionarea cu un server RESTful. Intr-o arhitetura 
client-server aceasta biblioteca este implementata in partea clientului si este o interfata API care respecta constrangerile arhitecturii REST. Este o 
biblioteca utilizata cu preponderenta in aplicatiile pentru sistemul de operare Android. In urmatoarele paragrafe sunt descrise caracteristicile cheie 
ale acestei biblioteci.

Aceasta biblioteca nu are implementat propriul mechanism petru tranzactionarea pachetelor HTTP, ci este integrata cu biblioteca OkHTTP. Aceasta din 
urma este o biblioteca complexa care implementeaza protocolul HTTP si toate mecanismele necesare de mitigare si rezolvare a erorilor in tranzactionarea 
prin retea. Are scopul de a automatiza complexitatea tranzactionarii prin retea pentru a usura utilizatorul de aceasta sarcina.
 
Biblioteca Retrofit este construita peste OkHTTP si rolul ei este de a automatiza parsarea si formatarea cererilor si raspunsurilor HTTP. Aceasta creeaza 
adresa URL si o trimite bibliotecii OkHTTP de unde este trimisa in retea. La primirea raspunsului, OkHTTP il trimite catre Retrofit care se ocupa de formatarea 
lui pentru a-l prezenta utilizatorului sub structura dorita, de exemplu, un obiect.

Figura \ref{fig:RetrofitStructure} prezinta functionalitatea bibliotecii retrofit. Aceasta va fi detaliata in paragrafele urmatoare.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{figs/RetrofitStructure.png}
    \caption{Structura bibliotecii Retrofit}
    \label{fig:RetrofitStructure}
\end{figure}

Modulul Android Activity reprezinta interfata cu utilizatorul in sistemul de operare android. In urma unui eveniment, de exemplu, apasare buton sau 
o rutina periodica, se trimite o cerere catre modulul API, care la finalul tranzactiei va returna informatia care va fi afisata utilizatorului.

Modulul API contine mai multe modele si o interfata. In interfata sunt declarate metodele utilizate pentru a obine date de la server, de exemplu, metoda 
GetAllClients care va informa serverul sa puna in raspuns o lista cu toti clientii din baza de date. Utilizand adnotari aceste metode sunt mapate pe adrese URL. 
Metode returneaza un model, acesta fiind o clasa care contine toate campurile primite de la server in raspuns. De exemplu, campurile nume, adresa, 
varsta. La construirea obiectului Retrofit se realizeaza maparea dintre adresa URL, metode, si modele. API trimite catre modulul RESTAdapter un obiect 
al clasei Call. Acest obiect este initializat cu metoda care se doreste a fi executata utilizand obiectul Retrofit. Acesteia i se mai ataseaza 
doua rutine, una care este executata in cazul in care tranzactia a fost efectuata cu success si una care se executa in caz 
contrar.

Modulul RESTAdapter primeste de la modulul API obiectul de tip Call care contine toate informatiile necesare pentru a executa cererea catre server. Obiectul Call 
este transpus in format OkHTPP si trimis catre modulul OkHTTP. La finalul tranzactiei acesta primeste un raspuns de tipul OkHTTP pe care il mapeaza, 
pe baza informatiilor din obiectul retrofit, intr-un obiect al clasei model specifice. Acest obiect este returnat modulului API.

Modulul OkHTTP se ocupa de tranzactionarea efectiva prin retea. Primeste si returneaza obiecte specifice acestei biblioteci.

Fiecare metoda din Retrofit este identifica unic de o adresa URL si identifica unic un set de date cerut de la un server. Fiecare set de date este 
reprezentat printr-o clasa model. Acest lucru face posibila maparea dintre URL, metoda si model. Metodele sunt mapate la adrese URL prin adnotari. 
In aceste adnotari se specifica metoda HTTP si adresa URL. Cele mai utilizate adnotari sunt prezentate mai jos:
\begin{enumerate}
	\item @Path - aceasta adnotare permite utilizarea de campuri variabile in adresa URL. Aceasta adnotare este un parametru al functiei, iar valoarea 
	pe care o primeste la apelul metodei este pusa in adresa URL.
    \item @Body - aceasta adnotare permite inserarea in adresa URL a unei clase model. Aceasta adnotare se utilizeaza la metodele HTTP de salvare 
    in baza de date, cum ar fi metoda POST.
    \item @FormUrlEncoded - aceasta adnotare permite inserarea in adresa URL a unor campuri dintr-un model cu scopul de a-l modifica in baza de date.
\end{enumerate}

Metodele in Retrofit sunt doar declarate intr-o interfata, nu si implementate, iar instructiunile necesare pentru a converti o cerere HTTP intr-o clasa java 
sunt generate automat de catre acesta. Retrofit suporta conversia automata a multor tipuri de format a datelor, cum ar fi GSON sau SimpleXML, dar acopera si 
cazul in care serverul returneaza un format de date care nu este suportat, prin crearea unui convertor particular. Acest lucru presupune scrierea 
manuala a instructiunilor necesare convertirii raspunsului de la server in obiect Java. Acest lucru nu trebuie facut petru fiecare resursa in parte, ci 
in mod general, o singura data.

GSON este o biblioteca in Java care are rolul de a serializa un obiect Java intr-un format JSON, respectiv de a deserializa un obbiect in format JSON intr-un 
obiect java.   

Clasa Call suporta executarea cererii HTTP in mod sincron sau asincron. Este de preferat modul asincron, deoarece executia are loc pe un fir separat lasand 
firu de executie creator sa execute alte sarcini. Aceasta clasa este dedicata pentru fiecare tranzactie, o instanta a acesteia poate fi utilizata pentru 
o singura transmisie a unei cereri HTTP si receptie a unui raspuns HTTP. La finalul unei tranzactii obiectul este distrus.



\section{IoT}\label{sec:iot}
\section{Distributed System}\label{sec:distributed}
\section{Zynq or Microprocessor architecture}\label{sec:zynq}
\section{C embedded modularization}\label{sec:cembedded}
\section{Data visualisation algorithms}\label{sec:graph}
\section{Baza de date MongoDB}\label{sec:mongodb}
MongoDB este o baza de date orientata pe documente fiind printre putinele baze de date diferita de cele uzuale care sunt relationale, adica stocheaza datele in tabele 
grupate intre ele prin relatii. Aceasta baza de date stocheaza datele in colectii de documente, de aici si denumirea de baza de date orientata pe documente. 
Structura acestui tip de baze de date permite un grad inalt de scalabilitate prin impartirea si distribuirea unei baze de date foarte mari pe mai multe 
servere. In paragrafele care urmeaza vor fi descrise caracteristicile cheie ale bazei de date.

Documentul reprezinta un singur set de date si poate fi asociat cu un inlocuitor al unui rand dintr-o baza de date relationala. Setul de date este stocat intr-un 
format numit BSON, Binary-JSON, care este o reprezentare in binar a formatului de fisiere JSON. Acesta din urma este un format de fisiere bazat pe text,
are o structura de tipul cheie-valoare si este usor de interpretat de catre om.

Figura \ref{fig:MongoDBDocument} prezinta structura unui document dintr-o baza de date MongoDB si, de asementea, formatul JSON.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{figs/mongoDBDocument.png}
    \caption{Exemplu de document [2]}
    \label{fig:MongoDBDocument}
\end{figure}

Colectiile de tip serii in timp reprezinta un tip de colectii optimizate pentru a stoca si interoga documentele ordonate in timp. Aceste documente au in 
componenta un camp obligatoriu care reprezinta momentul de timp la care datele au fost achizitionate. In documentul prezentat in figura \ref{fig:MongoDBDocument} 
se poate observa perechea de valori "day" si data si ora in format ISO. Acest tip de colectii este utilizat cu preponderenta in IoT datorita faptului ca sunt 
optimizate pentru structura de date uzuala unui senzor. O astfel de structura contine, in general, un moment de timp la care achizitia de date a fost efectuata, 
un identificator unic al senzorului, in mod uzual adresa MAC, si valoarea metricii sau a metricilor achizitionate.

MongoDB creeaza automat un indice, o cheie primara, pentru fiecare document pentru a se asigura ca nu exista doua documente cu acelasi indice. In acelasi timp 
permite creearea unui indice secundar care poate contine unul sau mai multe campuri din setul de date si care are ca scop plierea pe structura fiecarui set de date 
si pe tipul de interogari cel mai des efectuate. In cazul seriilor in timp cele mai uzuale interogari sunt bazate pe timp, deci indicele ar trebui sa contina campul 
de timp la care trebuie specificata si ordonarea elementelor, de exemplu, intr-un sistem in care interogarea cea mai des intalnita este retragerea documentelor 
din ultimele 24 de ore ordonarea trebuie efectuata in ordine descrescatoare a timpului. Pe langa campul de timp, indicele mai poate contine inca un camp pentru 
a acoperi cazurile in care interogarea se face nu doar pe o perioada de timp, ci si pe o alta valoare continuta in setul de date, de exemplu, campul care contine 
adresa MAC a senzorului. MongoDB va stoca datele in functie de acest indice obtinand astfel interogari foarte eficiente. Totodata un indice prea complex sau 
scris incorect va creste complexitatea scrierii in baza de date si automat va scadea eficienta. 


{\color{blue}Împreună cu \textbf{următoarele} 2 capitole trebuie să reprezinte aproximativ 70\% din total.\\}

Scopul acestui capitol este de a explica principiile funcționale ale aplicației implementate.
Aici se va descrie soluția propusă dintr-un punct de vedere teoretic - explicați și demonstrați proprietățile și valoarea teoretică:
\begin{itemize}
	\item algoritm utilizat sau propus
	\item protocoale utilizate
	\item modele abstracte
	\item explicații/argumentări logice ale soluției alese
	\item structura logică și funcțională a aplicației.
\end{itemize}


~\\\parbox[c]{\textwidth}{\color{red}\bfseries

NU SE FAC referiri la implementarea propriu-zisă.

NU SE PUN descrieri de tehnologii preluate cu copy-paste din alte surse sau lucruri care nu țin strict de proiectul propriu-zis (materiale de umplutură).
}

\section{Nume de secțiune}\label{sec:context}

\subsection{Nume de subsecțiune}\label{subsec:numesub}

Fiecare tabel introdus în lucrare este numerotat astfel: Tabel x.y, unde x reprezintă numărul capitolului, iar y numărul tabelului din capitol.
Se lasă un rând liber între tabel și paragraful anterior, respectiv posterior (tabelul~\ref{tab:nonlin}).

\begin{table}[ht]
    \caption{Rezultate}
    \centering                          % tabel centrat
    \begin{tabular}{|c|c|c|c|}          % 4 coloane centrate
        \hline
        Case & Method\#1 & Method\#2 & Method\#3 \\ [0.5ex]   % inserare tabel
        %heading
        \hline                              % linie orizontal simpla
        1 & 50 & 837 & 970 \\               % corpul tabelului
        2 & 47 & 877 & 230 \\
        3 & 31 & 25 & 415 \\[1ex]           % [1ex] adds vertical space
        \hline
    \end{tabular}
    % titlul tabelului
    \label{tab:nonlin}                % eticheta folosita pentru referirea tabelului in text; referirea in text se va face cu \ref{table:nonlin}
\end{table}


Fiecare figură introdusă în text este citată (de ex: în figura x.y este prezentată ...) și numerotată.
Numerotarea se face astfel Figura x.y unde x reprezintă numărul capitolului iar y numărul figurii în acel capitol.
Numerotarea o face automat latex pe baza etichetei (\verb+\label{}+).

Referirea unei figuri se face cu \verb+\ref{}+. De exemplu, referința: figura~\ref{fig:imag}.

\begin{figure}[ht]
    \centering
    \includegraphics[]{figs/test.jpg}
    \caption{Numele figurii}
    \label{fig:imag}
\end{figure}

